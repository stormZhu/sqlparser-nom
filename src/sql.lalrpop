use crate::ast;

grammar;

match {
    // keywords
    r"(?i)as" => "AS",
    r"(?i)bigint" => "BIGINT",
    r"(?i)bool" => "BOOL",
    r"(?i)boolean" => "BOOLEAN",
    r"(?i)create" => "CREATE",
    r"(?i)constraint" => "CONSTRAINT",
    r"(?i)from" => "FROM",
    r"(?i)int" => "INT",
    r"(?i)integer" => "INTEGER",
    r"(?i)key" => "KEY",
    r"(?i)limit" => "LIMIT",
    r"(?i)not" => "NOT",
    r"(?i)null" => "NULL",
    r"(?i)offset" => "OFFSET",
    r"(?i)primary" => "PRIMARY",
    r"(?i)select" => "SELECT",
    r"(?i)smallint" => "SMALLINT",
    r"(?i)table" => "TABLE",
    r"(?i)varchar" => "VARCHAR",
    r"(?i)where" => "WHERE",


    "," => ",",
    "." => ".",
    "(" => "(",
    ")" => ")",
    "*" => "*",
    "/" => "/",
    "+" => "+",
    "-" => "-",
    "=" => "=",
    "!=" => "!=",
    "<" => "<",
    "<=" => "<=",
    ">" => ">",
    ">=" => ">=",
    "||" => "||"
} else {
    r"[A-Za-z_][A-Za-z0-9_]*" => ID,
    r"[0-9]+" => UNSIGNED_INTEGER_LIT,
    r"([0-9]+)\.([0-9]+)?" => UNSIGNED_FLOAT_LIT,
    r"0x[0-9A-Fa-f]+" => HEX_LIT,
    r"'[^[[:cntrl:]]']*'" => SINGLE_QUOTED_STRING_LIT
}


//
// Statements
//
pub Statement: ast::Statement = {
    CreateTableStatement => ast::Statement::CreateTable(<>),
    SelectStatement => ast::Statement::Select(<>),
};
CreateTableStatement: ast::CreateTableStatement = {
    "CREATE" "TABLE" <name: Ident> "(" <columns: CommaSeparatedList<ColumnDef>> ")" => {
        ast::CreateTableStatement { name, columns }   
    },
};
SelectStatement: ast::SelectStatement = {
    <body:SetExpr> <limitoffset:LimitOffsetClause?> => {
        let (limit, offset) = limitoffset.map_or((None, None), |(limit, offset)| (limit, offset));
        ast::SelectStatement { body, limit, offset }
    },
};

LimitOffsetClause: (Option<ast::Expr>, Option<ast::Expr>) = {
    "LIMIT" <limit:Expr> => (Some(limit), None),
    "OFFSET" <offset:Expr> => (None, Some(offset)),
    "LIMIT" <limit:Expr> "," <offset:Expr> => (Some(limit), Some(offset)),
    "LIMIT" <limit:Expr> "OFFSET" <offset:Expr> => (Some(limit), Some(offset)),
};

ColumnDef: ast::ColumnDef = {
    <name: Ident> <column_type: DataType> <constraints: ColumnConstraint*>
        => ast::ColumnDef {
            name,
            column_type,
            constraints
        },
};

ColumnConstraint: ast::ColumnConstraint = {
    <name: ConstraintName?> "NOT" "NULL" 
        => ast::ColumnConstraint { name, constraint: ast::ColumnConstraintKind::NotNull },
    <name: ConstraintName?> "PRIMARY" "KEY" 
        => ast::ColumnConstraint { name, constraint: ast::ColumnConstraintKind::PrimaryKey },
};

ConstraintName: ast::Ident = {
    "CONSTRAINT" <name: Ident> => name,
};

pub SelectItem: ast::SelectItem = {
    Expr => ast::SelectItem::UnnamedExpr(<>),
    <expr:Expr> "AS" <alias:Ident> => ast::SelectItem::ExprWithAlias { expr, alias },
    "*" => ast::SelectItem::Wildcard,
};


//
// SetExpr
//
pub SetExpr: ast::SetExpr = {
    SelectSetExpr,
};
SelectSetExpr: ast::SetExpr = {
    "SELECT" <projection:CommaSeparatedList<SelectItem>> "FROM" <from:Ident> "WHERE"? <where_clause:Expr?> => ast::SetExpr::Select { projection, from, where_clause },
};


//
// Expr
//
pub Expr: ast::Expr = {
    CmpBinaryOpExpr,
};
CmpBinaryOpExpr: ast::Expr = {
    <l:CmpBinaryOpExpr> ">" <r:AddSubBinaryOpExpr> => ast::Expr::BinaryOp {left: Box::new(l), op: ast::BinaryOp::Gt, right: Box::new(r)},
    <l:CmpBinaryOpExpr> "<" <r:AddSubBinaryOpExpr> => ast::Expr::BinaryOp {left: Box::new(l), op: ast::BinaryOp::Lt, right: Box::new(r)},
    <l:CmpBinaryOpExpr> ">=" <r:AddSubBinaryOpExpr> => ast::Expr::BinaryOp {left: Box::new(l), op: ast::BinaryOp::GtEq, right: Box::new(r)},
    <l:CmpBinaryOpExpr> "<=" <r:AddSubBinaryOpExpr> => ast::Expr::BinaryOp {left: Box::new(l), op: ast::BinaryOp::LtEq, right: Box::new(r)},
    <l:CmpBinaryOpExpr> "=" <r:AddSubBinaryOpExpr> => ast::Expr::BinaryOp {left: Box::new(l), op: ast::BinaryOp::Eq, right: Box::new(r)},
    <l:CmpBinaryOpExpr> "!=" <r:AddSubBinaryOpExpr> => ast::Expr::BinaryOp {left: Box::new(l), op: ast::BinaryOp::NotEq, right: Box::new(r)},
    AddSubBinaryOpExpr,
};
AddSubBinaryOpExpr: ast::Expr = {
    <l:AddSubBinaryOpExpr> "+" <r:MulDivBinaryOpExpr> => ast::Expr::BinaryOp {left: Box::new(l), op: ast::BinaryOp::Add, right: Box::new(r)},
    <l:AddSubBinaryOpExpr> "-" <r:MulDivBinaryOpExpr> => ast::Expr::BinaryOp {left: Box::new(l), op: ast::BinaryOp::Sub, right: Box::new(r)},
    MulDivBinaryOpExpr,
};
MulDivBinaryOpExpr: ast::Expr = {
    <l:MulDivBinaryOpExpr> "*" <r:ParenthesizedExpr> => ast::Expr::BinaryOp {left: Box::new(l), op: ast::BinaryOp::Mul, right: Box::new(r)},
    <l:MulDivBinaryOpExpr> "/" <r:ParenthesizedExpr> => ast::Expr::BinaryOp {left: Box::new(l), op: ast::BinaryOp::Div, right: Box::new(r)},
    ParenthesizedExpr,
};
ParenthesizedExpr: ast::Expr = {
    "(" <expr:Expr> ")" => expr,
    LiteralExpr,
    IdentifierExpr,
};
LiteralExpr: ast::Expr = {
    Literal => ast::Expr::Literal(<>),
};
IdentifierExpr: ast::Expr = {
    Ident => ast::Expr::Identifier(<>),
};



UnaryOp: ast::UnaryOp = {
    "+" => ast::UnaryOp::Plus,
    "-" => ast::UnaryOp::Minus,
};

pub BinaryOp: ast::BinaryOp = {
    "+" => ast::BinaryOp::Add,
    "-" => ast::BinaryOp::Sub,
    "*" => ast::BinaryOp::Mul,
    "/" => ast::BinaryOp::Div,

    ">" => ast::BinaryOp::Gt,
    "<" => ast::BinaryOp::Lt,
    ">=" => ast::BinaryOp::GtEq,
    "<=" => ast::BinaryOp::LtEq,
    "=" => ast::BinaryOp::Eq,
    "!=" => ast::BinaryOp::NotEq,
};


//
// Data Types
//
DataType: ast::DataType = {
    BooleanType,
    SmallIntType,
    IntegerType,
    BigIntType,
    VarcharType,
};
BooleanType: ast::DataType = {
    "BOOL" => ast::DataType::Boolean,
    "BOOLEAN" => ast::DataType::Boolean,
};
SmallIntType: ast::DataType = {
    "SMALLINT" <length: LengthSpecification?> => ast::DataType::SmallInt(length),
};
IntegerType: ast::DataType = {
    "INT" <length: LengthSpecification?> => ast::DataType::Integer(length),
    "INTEGER" <length: LengthSpecification?> => ast::DataType::Integer(length),
};
BigIntType: ast::DataType = {
    "BIGINT" <length: LengthSpecification?> => ast::DataType::BigInt(length)
};
VarcharType: ast::DataType = {
    "VARCHAR" <length: LengthSpecification?> => ast::DataType::Varchar(length)
};


//
// Literal
//
pub Literal: ast::Literal = {
    StringLiteral => ast::Literal::String(<>),
    UnsignedFloatLiteral => ast::Literal::UnsignedFloat(<>),
    UnsignedIntegerLiteral => ast::Literal::UnsignedInteger(<>),
}
UnsignedIntegerLiteral: usize = {
    <num:UNSIGNED_INTEGER_LIT> => <>.parse::<usize>().unwrap(),
};
UnsignedFloatLiteral: f64 = {
    <num:UNSIGNED_FLOAT_LIT> => <>.parse::<f64>().unwrap(),
};
StringLiteral: String = {
    // remove single quotes
    <s:SINGLE_QUOTED_STRING_LIT> => s.chars().skip(1).take(s.len() - 2).collect(),
}


//
// Macros
//
CommaSeparatedList<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T> => {
        v.push(e);
        v
    }
};


Ident: ast::Ident = {
    ID => ast::Ident::new(<>.to_string()),
};

LengthSpecification: usize = {
    "(" <length: UnsignedIntegerLiteral> ")" => length,
};